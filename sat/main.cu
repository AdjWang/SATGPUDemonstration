#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <ctype.h>
#include <unistd.h>
#include "loader.h"
#include "sat.h"
#include "dependence.h"

static int print_overlap_result(FILE* stream, const int* overlap_indices, int n){
    int print_count = 0;
    int count = 0;
    for(int i=0; i<n; i++){
        if(overlap_indices[i] == 1){
            count++;
        }
    }
    print_count += fprintf(stream, "%d\n", count);
    print_count += fprintf(stream, "[");
    for(int i=0; i<n; i++){
        if(overlap_indices[i] == 1){
            print_count += fprintf(stream, "%d,", i);
        }
    }
    print_count += fprintf(stream, "]\n");
    return print_count;
}

static void print_usage(){
    fprintf(stderr, "usage: sat.out -i input_file [-o output_file] [-g]\n\
-i: input_file. Input polygon text file generated by generator.py\n\
-o: output_file. Optional. Default as stdout. Output polygon and SAT text file. Show graphic result by viewer.py\n\
-g: use gpu. Optional. A flag to set if running sat on GPU.\n\
e.g. sat.out -i polygon_input.txt\n\
     sat.out -i polygon_input.txt -o polygon_output.txt\n\
     sat.out -i polygon_input.txt -o polygon_output.txt -g\n");
}

int main(int argc, char* argv[]){
    // ASSERT(argc == 2, "invalid argument. usage: sat.out polygon_input.txt\n");
    // const char* input_file = argv[1];

    // 0. parse arguments
    char* input_file = NULL;
    char* output_file = NULL;
    int gpu_flag = 0;

    int c;
    opterr = 0;

    while((c = getopt(argc, argv, "i:o:g::")) != -1){
        switch(c){
            case 'i':
            input_file = optarg;
            break;
            
            case 'o':
            output_file = optarg;
            break;
            
            case 'g':
            gpu_flag = 1;
            break;

            case '?':
            if (optopt == 'i')
                fprintf (stderr, "Option -%c requires an argument.\n", optopt);
            else if (isprint (optopt))
                fprintf (stderr, "Unknown option `-%c'.\n", optopt);
            else
                fprintf (stderr,
                        "Unknown option character `\\x%x'.\n",
                        optopt);
            print_usage();
            return 1;

            default:
            fprintf(stderr, "opterr: %d, abort.\n", opterr);
            print_usage();
            abort();
        }
    }

    if(input_file == NULL){
        fprintf(stderr, "invalid argument.\n");
        print_usage();
        exit(1);
    }

    // 1. load input file
    FILE* ifp = fopen(input_file, "r");
    if(ifp == NULL){
        fprintf(stderr, "Error opening file %s: %s\n", input_file, strerror(errno));
        return errno;
    }
    polygon_t** polygon_list = NULL;
    int n = load_polygons(ifp, &polygon_list);
    ASSERT(polygon_list != NULL, "polygon_list is NULL, initialization failed");
    fclose(ifp);

    // 2. do sat detection
    int** result = (int**)malloc(n*sizeof(int*));
    if(!result){
        RAISE("malloc failed.\n");
    }
    for(int i=0; i<n; i++){
        result[i] = (int*)calloc(n, sizeof(int));
        if(!result[i]){
            RAISE("calloc failed.\n");
        }
    }

    double iStart=cpuSecond();
    if(gpu_flag == 1){
        detect_overlap_gpu(polygon_list, result, n);
    }else{
        detect_overlap(polygon_list, result, n);
    }
    double iElaps=cpuSecond()-iStart;
    printf("CPU Execution Time elapsed %f sec\n",iElaps);

    // 3. print results
    FILE* ofp = NULL;
    if(output_file == NULL){
        ofp = stdout;
    }else{
        ofp = fopen(output_file, "w");
        if(ofp == NULL){
            fprintf(stderr, "Error opening file %s: %s\n", output_file, strerror(errno));
            return errno;
        }
    }
    // print total number of polygons
    fprintf(ofp, "%d\n", n);
    // print polygons
    for(int i=0; i<n; i++){
        polygon_print(ofp, polygon_list[i]);
        print_overlap_result(ofp, result[i], n);
    }

    // 4. recycle resources
    // free polygons
    for(int i=0; i<n; i++){
        del_polygon(polygon_list[i]);
    }

    for(int i=0; i<n; i++){
        free(result[i]);
    }
    free(result);

    return 0;
}
